{"posts":[{"title":"Finalshell 3.0.10 高级免安装版","content":"前几天刚发现Finalshell高级免安装版的软件 压缩包解压就可以直接使用了，用了几天还不错 点击左侧两个区域可以查看自己的进程和服务器的延迟，下方区域可以上传和下载服务器的文件 Finalshell就等于xshell和FileZilla的结合版 其余功能可自行探索 想要解锁高级版直接点击左下角的升至高级版 下载链接 下载 ","link":"https://blog.kiwen.ga/post/finalshell-3010-gao-ji-mian-an-zhuang-ban/"},{"title":"利用cf的works搭建在线代理","content":"开源地址https://github.com/EtherDream/jsproxy/blob/master/cf-worker/index.js 搭建方法 使用 CloudFlare Worker 免费部署 简介 CloudFlare Worker 是 CloudFlare 的边缘计算服务。开发者可通过 JavaScript 对 CDN 进行编程，从而能灵活处理 HTTP 请求。这使得很多任务可在 CDN 上完成，无需自己的服务器参与。 部署 首页：https://workers.cloudflare.com 注册，登陆，Start building，取一个子域名，Create a Worker。 复制 index.js 到左侧代码框，Save and deploy。如果正常，右侧应显示首页。 收藏地址框中的 https://xxxx.子域名.workers.dev，以后可直接访问。 计费 后退到 overview 页面可参看使用情况。免费版每天有 10 万次免费请求，对于个人通常足够。 如果不够用，可注册多个 Worker，在 conf.js 中配置多线路负载均衡。或者升级到 $5 的高级版本，每月可用 1000 万次请求（超出部分 $0.5/百万次请求）。 修改配置 默认情况下，静态资源从 https://etherdream.github.io/jsproxy 反向代理，可通过代码中 ASSET_URL 配置，从而可使用自定义的 conf.js 配置。 存在问题 WebSocket 代理尚未实现 外链限制尚未实现 未充分测试，以后再完善 ","link":"https://blog.kiwen.ga/post/li-yong-cf-de-works-da-jian-zai-xian-dai-li/"},{"title":"SSF构建过程","content":"SSF构建过程 源码分析 首先创建一个SqlSesionFactoryBuilder对象 [Java] 纯文本查看 复制代码 ? 1 2 3 4 5 public class SqlSessionFactoryBuilder { public SqlSessionFactoryBuilder() { } //省略其它代码 } 其次 SSFB 对象调用 build 方法 [Java] 纯文本查看 复制代码 ? 1 2 3 public SqlSessionFactory build(InputStream inputStream) { return this.build((InputStream)inputStream, (String)null, (Properties)null); } 然后再看他的重载方法 [Java] 纯文本查看 复制代码 ? 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) { try { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); } catch (Exception e) { throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e); } finally { ErrorContext.instance().reset(); try { inputStream.close(); } catch (IOException e) { // Intentionally ignore. Prefer previous error. } } } 这个构造函数将我们的配置文件转换为 XMLConfigBuilder 对象，这个很复杂，由于时间，再发帖另论 [Java] 纯文本查看 复制代码 ? 1 return build(parser.parse()); 这里有两处注意的地方，parser.parse() 返回一个Configuration 对象，这个对象保罗万千，暂时也不深究。此外build方法的实现如下： [Java] 纯文本查看 复制代码 ? 1 2 3 public SqlSessionFactory build(Configuration config) { return new DefaultSqlSessionFactory(config); } 它返回了 DefaultSqlSessionFactory对象，并且将 Configuration 对象赋值其属性 [Java] 纯文本查看 复制代码 ? 1 2 3 4 5 6 7 8 9 public class DefaultSqlSessionFactory implements SqlSessionFactory { private final Configuration configuration; public DefaultSqlSessionFactory(Configuration configuration) { this.configuration = configuration; } //这里省略其它代码 } 由于 DefaultSqlSessionFactory 实现了 SSF 接口，那麽 [Java] 纯文本查看 复制代码 ? 1 2 3 4 5 6 7 8 9 public class DefaultSqlSessionFactory implements SqlSessionFactory { private final Configuration configuration; public DefaultSqlSessionFactory(Configuration configuration) { this.configuration = configuration; } //这里省略其它代码 } 这个就结束了 源码的设计思想 首先先定义SSF接口 [Asm] 纯文本查看 复制代码 ? 1 2 3 4 5 package com.yefengyu.mybatis; public interface SqlSessionFactory { void test(); } 然后通过编写代码来实现调用接口 [Java] 纯文本查看 复制代码 ? 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 package com.yefengyu.mybatis; import org.apache.ibatis.builder.xml.XMLConfigBuilder; import org.apache.ibatis.session.Configuration; import java.io.InputStream; public class DefaultSqlSessionFactory implements SqlSessionFactory { private Configuration configuration = null; public DefaultSqlSessionFactory(InputStream inputStream) { XMLConfigBuilder parser = new XMLConfigBuilder(inputStream); this.configuration = parser.parse(); } @Override public void test() { //使用 configuration 完成相关功能 } } 测试一下 [Java] 纯文本查看 复制代码 ? 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 package com.yefengyu.mybatis; import org.apache.ibatis.io.Resources; import java.io.IOException; import java.io.InputStream; public class Main { public static void main(String[] args) throws IOException { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory(inputStream); sqlSessionFactory.test(); } } 这种方式也有一定的缺点 就是首先如果有多个SSF实现的话，把 InputStream 转换为 Configuration的过程在每个构造函数都会有。 上面的SSF指的是SqlSessionFactory SSFB值得是SqlSessionFactoryBuilder 请求批评指正 如果乱码，看52上我发的https://www.52pojie.cn/thread-1174330-1-1.html ","link":"https://blog.kiwen.ga/post/ssf-gou-jian-guo-cheng/"}]}