<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.kiwen.ga</id>
    <title>Kiwen&apos;s Blog</title>
    <updated>2020-07-06T00:53:19.972Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.kiwen.ga"/>
    <link rel="self" href="https://blog.kiwen.ga/atom.xml"/>
    <logo>https://blog.kiwen.ga/images/avatar.png</logo>
    <icon>https://blog.kiwen.ga/favicon.ico</icon>
    <rights>All rights reserved 2020, Kiwen&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Finalshell 3.0.10 高级免安装版]]></title>
        <id>https://blog.kiwen.ga/post/finalshell-3010-gao-ji-mian-an-zhuang-ban/</id>
        <link href="https://blog.kiwen.ga/post/finalshell-3010-gao-ji-mian-an-zhuang-ban/">
        </link>
        <updated>2020-07-06T00:27:38.000Z</updated>
        <content type="html"><![CDATA[<p>前几天刚发现Finalshell高级免安装版的软件</p>
<p>压缩包解压就可以直接使用了，用了几天还不错<br>
点击左侧两个区域可以查看自己的进程和服务器的延迟，下方区域可以上传和下载服务器的文件<br>
Finalshell就等于xshell和FileZilla的结合版<br>
<img src="https://blog.kiwen.ga/post-images/1593995337084.png" alt="" loading="lazy"><br>
其余功能可自行探索</p>
<figure data-type="image" tabindex="1"><img src="https://blog.kiwen.ga/post-images/1593995340826.png" alt="" loading="lazy"></figure>
<p>想要解锁高级版直接点击左下角的升至高级版<br>
下载链接     <a href="https://pcm4tco5qwrpswel2fln.sharepoint.com/:u:/s/movie/ESpb9qxshTlCqPjgQFmplnIBr_ICqG1k6zF7Ee3TV4Tolw?e=vHEp9o">下载</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用cf的works搭建在线代理]]></title>
        <id>https://blog.kiwen.ga/post/li-yong-cf-de-works-da-jian-zai-xian-dai-li/</id>
        <link href="https://blog.kiwen.ga/post/li-yong-cf-de-works-da-jian-zai-xian-dai-li/">
        </link>
        <updated>2020-07-05T13:15:35.000Z</updated>
        <content type="html"><![CDATA[<p>开源地址https://github.com/EtherDream/jsproxy/blob/master/cf-worker/index.js<br>
搭建方法<br>
使用 CloudFlare Worker 免费部署</p>
<p>简介<br>
CloudFlare Worker 是 CloudFlare 的边缘计算服务。开发者可通过 JavaScript 对 CDN 进行编程，从而能灵活处理 HTTP 请求。这使得很多任务可在 CDN 上完成，无需自己的服务器参与。</p>
<p>部署<br>
首页：https://workers.cloudflare.com</p>
<p>注册，登陆，Start building，取一个子域名，Create a Worker。</p>
<p>复制 index.js 到左侧代码框，Save and deploy。如果正常，右侧应显示首页。</p>
<p>收藏地址框中的 https://xxxx.子域名.workers.dev，以后可直接访问。</p>
<p>计费<br>
后退到 overview 页面可参看使用情况。免费版每天有 10 万次免费请求，对于个人通常足够。</p>
<p>如果不够用，可注册多个 Worker，在 conf.js 中配置多线路负载均衡。或者升级到 $5 的高级版本，每月可用 1000 万次请求（超出部分 $0.5/百万次请求）。</p>
<p>修改配置<br>
默认情况下，静态资源从 https://etherdream.github.io/jsproxy 反向代理，可通过代码中 ASSET_URL 配置，从而可使用自定义的 conf.js 配置。</p>
<p>存在问题<br>
WebSocket 代理尚未实现</p>
<p>外链限制尚未实现</p>
<p>未充分测试，以后再完善</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSF构建过程]]></title>
        <id>https://blog.kiwen.ga/post/ssf-gou-jian-guo-cheng/</id>
        <link href="https://blog.kiwen.ga/post/ssf-gou-jian-guo-cheng/">
        </link>
        <updated>2020-07-05T10:42:42.000Z</updated>
        <content type="html"><![CDATA[<p>SSF构建过程<br>
源码分析<br>
首先创建一个SqlSesionFactoryBuilder对象<br>
[Java] 纯文本查看 复制代码<br>
?<br>
1<br>
2<br>
3<br>
4<br>
5<br>
public class SqlSessionFactoryBuilder {<br>
public SqlSessionFactoryBuilder() {<br>
}<br>
//省略其它代码<br>
}</p>
<p>其次 SSFB 对象调用 build 方法<br>
[Java] 纯文本查看 复制代码<br>
?<br>
1<br>
2<br>
3<br>
public SqlSessionFactory build(InputStream inputStream) {<br>
return this.build((InputStream)inputStream, (String)null, (Properties)null);<br>
}</p>
<p>然后再看他的重载方法<br>
[Java] 纯文本查看 复制代码<br>
?<br>
01<br>
02<br>
03<br>
04<br>
05<br>
06<br>
07<br>
08<br>
09<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {<br>
try {<br>
XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);<br>
return build(parser.parse());<br>
} catch (Exception e) {<br>
throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);<br>
} finally {<br>
ErrorContext.instance().reset();<br>
try {<br>
inputStream.close();<br>
} catch (IOException e) {<br>
// Intentionally ignore. Prefer previous error.<br>
}<br>
}<br>
}</p>
<p>这个构造函数将我们的配置文件转换为 XMLConfigBuilder 对象，这个很复杂，由于时间，再发帖另论<br>
[Java] 纯文本查看 复制代码<br>
?<br>
1<br>
return build(parser.parse());</p>
<p>这里有两处注意的地方，parser.parse() 返回一个Configuration 对象，这个对象保罗万千，暂时也不深究。此外build方法的实现如下：<br>
[Java] 纯文本查看 复制代码<br>
?<br>
1<br>
2<br>
3<br>
public SqlSessionFactory build(Configuration config) {<br>
return new DefaultSqlSessionFactory(config);<br>
}</p>
<p>它返回了 DefaultSqlSessionFactory对象，并且将 Configuration 对象赋值其属性<br>
[Java] 纯文本查看 复制代码<br>
?<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
public class DefaultSqlSessionFactory implements SqlSessionFactory {</p>
<p>private final Configuration configuration;</p>
<p>public DefaultSqlSessionFactory(Configuration configuration) {<br>
this.configuration = configuration;<br>
}<br>
//这里省略其它代码<br>
}</p>
<p>由于 DefaultSqlSessionFactory 实现了 SSF 接口，那麽<br>
[Java] 纯文本查看 复制代码<br>
?<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
public class DefaultSqlSessionFactory implements SqlSessionFactory {</p>
<p>private final Configuration configuration;</p>
<p>public DefaultSqlSessionFactory(Configuration configuration) {<br>
this.configuration = configuration;<br>
}<br>
//这里省略其它代码<br>
}</p>
<p>这个就结束了</p>
<p>源码的设计思想<br>
首先先定义SSF接口<br>
[Asm] 纯文本查看 复制代码<br>
?<br>
1<br>
2<br>
3<br>
4<br>
5<br>
package com.yefengyu.mybatis;</p>
<p>public interface SqlSessionFactory {<br>
void test();<br>
}</p>
<p>然后通过编写代码来实现调用接口<br>
[Java] 纯文本查看 复制代码<br>
?<br>
01<br>
02<br>
03<br>
04<br>
05<br>
06<br>
07<br>
08<br>
09<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
20<br>
21<br>
package com.yefengyu.mybatis;</p>
<p>import org.apache.ibatis.builder.xml.XMLConfigBuilder;<br>
import org.apache.ibatis.session.Configuration;</p>
<p>import java.io.InputStream;</p>
<p>public class DefaultSqlSessionFactory implements SqlSessionFactory {</p>
<pre><code>private Configuration configuration = null;  

public DefaultSqlSessionFactory(InputStream inputStream) {  
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream);  
    this.configuration = parser.parse();  
}  

@Override
public void test() {  
    //使用 configuration 完成相关功能  
}  
</code></pre>
<p>}</p>
<p>测试一下<br>
[Java] 纯文本查看 复制代码<br>
?<br>
01<br>
02<br>
03<br>
04<br>
05<br>
06<br>
07<br>
08<br>
09<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
package com.yefengyu.mybatis;</p>
<p>import org.apache.ibatis.io.Resources;</p>
<p>import java.io.IOException;<br>
import java.io.InputStream;</p>
<p>public class Main {<br>
public static void main(String[] args) throws IOException {<br>
String resource = &quot;mybatis-config.xml&quot;;<br>
InputStream inputStream = Resources.getResourceAsStream(resource);<br>
SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory(inputStream);<br>
sqlSessionFactory.test();<br>
}</p>
<p>}</p>
<p>这种方式也有一定的缺点<br>
就是首先如果有多个SSF实现的话，把 InputStream 转换为 Configuration的过程在每个构造函数都会有。</p>
<p>上面的SSF指的是SqlSessionFactory<br>
SSFB值得是SqlSessionFactoryBuilder</p>
<p>请求批评指正</p>
<p>如果乱码，看52上我发的https://www.52pojie.cn/thread-1174330-1-1.html</p>
]]></content>
    </entry>
</feed>